---
title: "Data cleaning and identifier mapping"
subtitle: "Assignment 1 for BCB420 Winter 2023"
author: Jielin Yang
date: Feb. 14th, 2023
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
    df_print: paged
    highlight: pygments
bibliography: Assignment1.bib
csl: "../american-medical-association.csl"
---

<style type="text/css">
    body {
    max-width: 100%;
    overflow-x: auto;
    font-family: Helvetica;
    font-size: 12pt;
    }
    h1 {
    font-size: 20pt;
    font-weight: bold;
    }
    h2 {
        font-size: 18pt;
        font-weight: bold;
    }
    h3 {
        font-size: 16pt;
        font-weight: bold;
    }
    h4 {
        font-size: 14pt;
        font-weight: bold;
    }
    code {
        font-family: monospace;
        font-size: 11pt;
    }
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
knitr::opts_knit$set(root.dir = here::here())  # Must be the project directory
```
    


# Introduction

## Background

Heart failure (HF) is one of the most common and life-threatening syndrome 
associated with progressive morbidity and mortality that has implicated over 65 
million patients worldwide in 2017. [@savarese2022global] It is characterized by 
the reduced capacity of the heart to pump sufficient blood to meet the metabolic
demands of the body. The pathogenesis of HF is complex and involves multiple 
factors, but one of the earliest hallmark of the disease is maladaptive
remodelling of the myocardium. [@garoffolo2022reduction] During remodelling, the
damaged cardiomyocytes (which can be resulted from ventricular overload, altered
metabolic composition, etc.) are replaced by fibrotic scar tissues.
 [@porter2009cardiac] [@tallquist2017redefining] The altererd extracellular 
matrix (ECM) increased myocardial stiffness and thus further
contributes to the progression of HF. [@perestrelo2021multiscale] Therefore, the
identification of the key genes and pathways that are involved in profibrotic 
remodeling is critical for the development of novel therapeutic teachniques.

Earlier studies have established a connection between both static and dynamic 
cytoskeletal tension between cells as a result of cellular adhesion to ECM with 
the transactivation of the Hippo signaling pathway. [@brusatin2018biomaterials] 
In particular, it was found that an increased nuclear entry of the YAP/TAZ 
complex, which is a potent transcriptional activator of proliferative genes, is 
a result of the inhibition of the repressive kinease regulators and deformation 
of the nuclear lamina under mechanical strains. [@panciera2017mechanobiology] 
[@elosegui2017force]
Recently, this finding has been extended to myofibroblasts, which are the major 
contributor of cardiac fibrosis derived from the quiescence cardiac stromal cells
. [@francisco2020blockade] Hence, 
[Garoffolo et al.](https://doi.org/10.1161/CIRCRESAHA.121.319373) aims to 
elicidate the connection between the abnormal straining forces in cardiac 
myocardium and the YAP-dependent transcriptional activation in profibrotic 
cells. [@garoffolo2022reduction] In addition, they tested whether direct 
pharmaceutical inhibition of the YAP/TAZ complex with verteporfin (VTP), a known
drug that interferes the binding of YAP to its target TEAD, can attenuate the 
progression of cardiac fibrosis with and without the presence of the potent 
profibrotic cytokine TGF-β1. [@giraud2020verteporfin] [@piersma2015signaling]

## Objectives
The research study aimed to establish the connection between the response of 
human myocardial stromal cells (cSt-Cs) to straining forces and the activation 
of the profibrotic pathway downsteam of YAP/TAZ. In addition, they tested 
whether the inhibition of YAP/TAZ translocation to the nucleus. 
[@garoffolo2022reduction]

Here, we focused on a particular part of the larger objective, where we 
incorporated the RNA sequencing data to differentially compare the molecular 
signitures of the cSt-Cs under known mechanical strains that activate 
profibrotic pathways.
We hope to identify whether the direct inactivation of the YAP/TAZ complex with 
VTP under *in vitro* conditions is able to attenuate the progression of cardiac 
fibrosis, with and without the presence of TGF-β. [@garoffolo2022reduction]

## Data
As documented in the previous [journal](https://github.com/bcb420-2023/Jielin_Yang/wiki/Gene-Expression-Dataset-Selection) 
and [R Notebook](https://github.com/bcb420-2023/Jielin_Yang/blob/main/Data%20set%20selection%20and%20initial%20processing/Gene_Expression_Dataset_Selection.Rmd),
we have performed a search for gene expression datasets that are related to the 
topic of our research project using both the GEOmetadb and the NCBI GEO database.
Upon reviewing the results, we have selected the dataset with the accession number [GSE203358](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE203358) for 
further analysis.
This dataset is part of a study that has been published in Circulation Research.
The original publication can be found 
[here](https://doi.org/10.1161/CIRCRESAHA.121.319373).

## Study Summary
### Publication Title
Reduction of Cardiac Fibrosis by Interference With YAP-Dependent Transactivation

### General Experimental Design
To access whether direct inhibition of the YAP/TAZ complex contributes to
anti-fibrotic activities under chronic mechanical strain and profibrotic 
signalling, RNA sequencing was performed in the following way. 
Cardiospheres-derived primitive cardiac stromal cells (cSt-Cs) were derived from
cardiospheres retrieved from human myocardial explant tissues. cSt-Cs were then 
treated with ±verteporfin (VTP) and ±TGF-β1 under *in vitro* culture conditions 
under maximum strain exerted by glass slides.
Total RNA was extracted from each independent cell culture 72 hours after
phamalogical treatments using the Trizol method. RNA library was made following 
enrichment of the polyadenylated mRNAs.

![**Figrue 1.** Schematics of RNAseq experiment design. Samples were cultured under maximal mechanical strains. Six independent cell cultures were used for each treatment condition. cSt-Cs:  cardiospheres-derived primitive cardiac stromal cells; VTP: verteporfin; TGF-β1: transforming growth factor beta-1. Figure created with BioRender.com](https://github.com/bcb420-2023/Jielin_Yang/raw/main/images/schematics.png)

# Preparations

The current R Notebook assumes that it is being run on the BCB420-2023 base 
image. Additional packages required are noted below.

```{r, message = FALSE, tidy=TRUE}
# BiocManager for installing a set of Bioconductor packages
if (! requireNamespace("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager")
}

# GEOquery package for querying the GEO database
if (! requireNamespace("GEOquery", quietly = TRUE)) {
  BiocManager::install("GEOquery")
}

# edgeR package for manupulating and analyzing RNAseq data
if (! requireNamespace("edgeR", quietly = TRUE)) {
  BiocManager::install("edgeR")
}

# biomaRt package for querying the Ensembl database
if (! requireNamespace("biomaRt", quietly = TRUE)) {
  BiocManager::install("biomaRt")
}

# stringr package for string manipulation
if (! requireNamespace("stringr", quietly = TRUE)) {
  install.packages("stringr")
}

# KableExtra package for creating tables and formatting
if (! requireNamespace("kableExtra", quietly = TRUE)) {
  install.packages("kableExtra")
}

# dplyr package for data manipulation
if (! requireNamespace("dplyr", quietly = TRUE)) {
  install.packages("dplyr")
}

# DT package for creating interactive tables
if (! requireNamespace("DT", quietly = TRUE)) {
  install.packages("DT")
}

# ggplot2 package for data visualization
if (! requireNamespace("ggplot2", quietly = TRUE)) {
  install.packages("ggplot2")
}

# here package for file path management
if (! requireNamespace("here", quietly = TRUE)) {
  install.packages("here")
}

# Load the dplyr package
library("dplyr")

# Load the ggplot2 package
library("ggplot2")

# We will consistently use package::function() to avoid confusion
# However, the dplyr package has to be loaded first to allow
# definitions of various operators such as %>%
```


# Data Download and Initial Characterization

## Dataset Description

In the previous section, we have discussed the study design of the RNA sequencing.
The RNAseq data generated in this study constitutes the second part of the
larger study, where the authors tested direct pharmaceutical inhibition of the
YAP/TAZ complex with verteporfin (VTP), after revealing that mechanical straining
of the cardiac stromal cells (cSt-Cs) activates the YAP/TAZ complex. 
[@garoffolo2022reduction] To better understand the dataset itself, here we 
retrieve the GEO description of the dataset.

```{r, message = FALSE, tidy=TRUE}
# Accession number
geoAcc <- "GSE203358"

# Retrieve the metadata given the GSE series accession number
# Set GESMatrix to FALSE as it is specific to microarray data
gse <- GEOquery::getGEO(geoAcc, GSEMatrix = FALSE)

# Further metadata can be retrieved regarding the platform used
gpl <- names(GEOquery::GPLList(gse))[1]
gplInfo <- GEOquery::Meta(GEOquery::getGEO(gpl))
```

Summary of the dataset metadata:

- **GEO Accession Number:** GSE203358
- **Title:** `r GEOquery::Meta(gse)$title`
- **Platform:** `r gplInfo$title`
- **Submission date:** `r gplInfo$submission_date`
- **Last update date:** `r GEOquery::Meta(gse)$last_update_date`
- **Organism:** `r paste(gplInfo$organism, paste0("(taxid: ", gplInfo$taxid, ")"), collapse = " ")`
- **Number of samples:** `r length(GEOquery::GSMList(gse))`
- **Link to BioProject:** [`r substring(GEOquery::Meta(gse)$relation, first = 13)`](`r substring(GEOquery::Meta(gse)$relation, first = 13)`)
- **Overall study design (by the [authors](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE203358)):** `r GEOquery::Meta(gse)$overall_design`


## Data Download
The description of the dataset shows that there are a total of 24 samples, with
6 replicates for each of the 4 treatment conditions. We will download the raw
data from the GEO database and store it in a local directory.

```{r, message = FALSE, tidy=TRUE}
# A `./Data` directory has been created to store the data.
# We will download the raw data using the GEOquery package.

# Check if the data file exists, and if not, download and decompress it
if (! file.exists("./Data/GSE203358_Count_Matrix.txt")) {
  sfiles = GEOquery::getGEOSuppFiles(geoAcc, makeDirectory = FALSE, 
                                     baseDir = "./Data")
  fnames = rownames(sfiles)
  GEOquery::gunzip(fnames[1])
}
```

Only one data file exists for this study. The raw counts for all 24 samples are
located in the file: `r list.files(path = "./Data", pattern = "\\.txt")`

## Preliminary Data Checking
The raw counts are stored in a tab-delimited text file. We will import the data
into R using the `read.table()` function.

```{r, message = FALSE, tidy=TRUE}
# Get the unzipped file name
file <- list.files(path = "./Data", pattern = "\\.txt")

# Import the raw counts into R
raw_counts <- read.table(paste0("./Data/", file), sep = "\t", 
                        header = TRUE, check.names = FALSE)

colnames(raw_counts)
```

There are 25 columns in the dataset, with the first column as gene ID, and 
the rest with 1 column per sample

```{r, message = FALSE, tidy=TRUE}
# Rename the rows with gene ID
rownames(raw_counts) <- raw_counts$Geneid

# Visualize the first 5 genes
head(raw_counts)
```

The dataset does not contain the original Ensembl gene IDs, whereas the HUGO
gene symbols are used.


# Data QC and Processing

## Sample Matrix

First we will retrieve the smaple design matrix, and retrieve the replicate
names under each of the four conditions

```{r, message = FALSE, tidy=TRUE}
# Obtain the sample names and treatment conditions using the column names from
# the dataset
samples <- data.frame(lapply(colnames(raw_counts)[2:25], 
                             function(x){unlist(strsplit(x, split = "\\."))}))

# rename the dataframe
colnames(samples) <- colnames(raw_counts)[2:25]
rownames(samples) <- c("culture_rep","treatment")

# Perform a matrix transposition, so that individual samples are listed in rows
# Construct a data frame of the sample design matrix
samples <- data.frame(t(samples))

# Order the samples by their treatment conditions
samples <- samples[order(samples$treatment), ]

samples
```

## Mapped Genes

### Gene duplication

We will first assess whether there are any duplicated genes in the dataset.

```{r, message = FALSE, tidy=TRUE}
# How many genes are mapped in the data set?
dim(raw_counts)
```

There are a total of `r dim(raw_counts)[1]` rows in the dataset, indicating the
number of genes mapped. We will now deduplicate them and see if there is any 
duplicated the genes.

```{r, message = FALSE, tidy=TRUE}
# Number of unique genes mapped
length(unique(raw_counts$Geneid))

# Whether there are any dupilcated genes
!(length(unique(raw_counts$Geneid)) == dim(raw_counts)[1])    # No duplication
```

### Gene mapping

Previously, we did not observe any duplicated genes in the dataset based on the gene names.
According to the method section the publication, total RNA was extracted from the cells
and subjected to library preparation using the poly-A enrichment method. Therefore, it
is expected that the genes selected for sequencing and analysis are protein-coding genes.
We will now check the highly expressed genes in the dataset, and see if these genes 
are consistent with our expectation. Since we only have gene names rather than
Ensembl gene ID, we can directly search for and understand potential functions of 
these highly expressed genes. While we are not performing differential gene 
expression analysis, understanding the most highly enriched genes would allow us
to check whether the general gene expression profile matches with the experimental
condition, i.e, cells cultured under profibrotic mechanical strains.

```{r, message = FALSE, tidy=TRUE}
# Calculate the total counts for each gene and sort them in descending order
sumGeneCounts <- rowSums(raw_counts[, 2:25])
names(sumGeneCounts) <- raw_counts$Geneid
sumGeneCounts <- sort(sumGeneCounts, decreasing = TRUE)

# Genes with expression values > 1, and show the top 10
knitr::kable(sumGeneCounts[sumGeneCounts > 1][1:10], format = "html", 
             col.names = "Frequency") %>% 
            kableExtra::kable_styling(bootstrap_options = c("striped", "hover", 
                "condensed", "responsive"), position = "center", full_width = F)
```

The most highly expressed gene is `FN1`, which encodes Fibronectin, which has been
found to be highly enriched in the extracellular matrix (ECM) of the heart tissue
following myocardial injury. [@wang2013fibronectin] Additionally, we have seen
`COL1A1`, `COL1A2` genes, which encode different chains of type 1 collagen that
are a common marker for fibrotic scars. [@hua2020multi] [@umbarkar2021mechanisms]
The gene expression profile is consistent with the expectation, as the highly
expressed genes (raw counts) across all biological replicates and test conditions
are found to be associated with fibrosis and ECM remodelling.

### Summary Statistics

We will then calculate the summary statistics for the raw counts for each 
of the 24 samples.

```{r, message = FALSE, tidy=TRUE}
# Calculate the summary statistics for the raw counts
summaryStats <- data.frame(apply(raw_counts[, 2:25], 2, summary))

# Visualize with a table
summaryStats
```

Since the samples are sequenced multiplexed in the same lane, under a randomized 
assumption, these samples should have similar sequencing depth. There are slight
variations in terms of the global distribution of the raw counts. We will check if
these variations are present between the different treatment conditions.

```{r, message = FALSE, tidy=TRUE}
# Calculate the summary statistics for the raw counts for each treatment condition

# Control
summaryCtrl <- summary(rowMeans(raw_counts[, grep("CTRL", colnames(raw_counts))]))

# TGFb only
summaryTGFb <- summary(rowMeans(raw_counts[, grep("TGFb$", colnames(raw_counts))]))

# VTP only
summaryVTP <- summary(rowMeans(raw_counts[, grep("VTP$", colnames(raw_counts))]))

# VTP + TGFb
summaryVTP_TGFb <- summary(rowMeans(raw_counts[, grep("TGFb_VTP", colnames(raw_counts))]))

# Combine the data frames and visualize
sumStats <- rbind(summaryCtrl, summaryTGFb, summaryVTP, summaryVTP_TGFb)
rownames(sumStats) <- c("CTRL", "TGFb", "VTP", "VTP_TGFb")
knitr::kable(sumStats, format = "html", col.names = colnames(sumStats)) %>% 
            kableExtra::kable_styling(bootstrap_options = c("striped", "hover", 
                              "condensed", "responsive"), position = "center")
```

The mean values of the raw counts are similar across the different treatment. This 
suggests that the previously observed variations in the raw counts are mainly 
due to the biological replicates.


### Data Filtering
Since the presence of lowly expressed genes would not contribute to the downstream
analysis, which would even decrese the statistical power and sensitivity of detecting 
differentially expressed genes, we will filter out the genes with low gene counts.
[@sha2015effect]

According to the edgeR protocol, we will filter out the genes with no more than 
1 read per million in 6 of the samples, because for each treatment condition we
have 4 biological replicates. [@anders2013count]

```{r, message = FALSE, tidy=TRUE}
# Translating the raw counts into counts per million (CPM)
cpm <- edgeR::cpm(raw_counts[, 2:25])
# and rename the gene names
rownames(cpm) <- raw_counts$Geneid

# Filter out the genes with no more than 1 read per million in 6 of the samples
# We will use pothole case for variable to hold the expression data, and camel case
# for any other variables
keep <- rowSums(cpm > 1) >= 6
raw_counts_filtered <- raw_counts[keep, ]

# Visualize the summary statistics for the filtered dataset
dim(raw_counts_filtered)
```

It is observed that `r (dim(raw_counts)[1] - dim(raw_counts_filtered)[1])/dim(raw_counts)[1] * 100`% 
of the genes were filtered out due to low number of reads.
Only `r dim(raw_counts_filtered)[1]` (`r dim(raw_counts_filtered)[1]/dim(raw_counts)[1] * 100`%) 
genes were retained for downstream analysis.


# ID Mapping

## Gene Names and ID

Upon further checking of the dataset, we have found that the gene names are not completely
consistent with the HUGO gene symbols. Many genes have been annotated with the HUGO gene
symbols, as shown in the several highly expressed genes in the previous section. However,
there are also genes that are annotated with the 
[GenBank](https://www.ncbi.nlm.nih.gov/genbank/) gene
accession numbers. We now check how many genes are annotated with the GenBank accession. Upon 
observation, ENA gene symbols are composed of 2 parts, separated by a dot. The first part
is 1-2 letters followed by 5-6 digits, after which there is a dot, and then the second part
is a digit indicating the version of the gene. Since the nomenclature of the 
[HUGO Gene Nomenclature Committee (HGNC)](https://www.genenames.org/) specifies
that the gene symbols do not contain a dot, we will search for the dot in the gene names
to identify the ENA gene symbols.

```{r, message = FALSE, tidy=TRUE}
# Check how many genes are annotated with the ENA gene symbols
sum(grepl("\\.", rownames(raw_counts_filtered)))

# To confirm, we also check how many genes are annotated with 2 letters followed by 6 digits
sum(grepl("^[A-Z]{1,2}[0-9]{5,6}", rownames(raw_counts_filtered)))
```

The two method does not retrieve exactly the same number of genes, yet this is similar. 
We will check the genes that are not found similarly by the two methods.

```{r, message = FALSE, tidy=TRUE}
# Get the index of the genes that are returned by each method
byDots <- grep("\\.", rownames(raw_counts_filtered))
byName <- grep("^[A-Z]{1,2}[0-9]{5,6}", rownames(raw_counts_filtered))

# Genes that are differently identified by the two methods
rownames(raw_counts_filtered)[setdiff(byDots, byName)]
```

The gene **`r rownames(raw_counts_filtered)[setdiff(byDots, byName)]`** was identified
by the first method but not by the second method. Upon further checking the
gene with various resources, we found that the gene is not annotated in the
HGNC database. However, it is documented in the GenBank database. Further cross-referencing
with other literatures allowed us to realized that this gene is a long non-coding RNA,
which has been identified as a differntially expressed lncRNA in a human iPSC-derived
cardiomyocytes hypertrophy model. [@pohjolainen2022transcriptomics] Therefore, we 
will keep this gene in the dataset.

Since there are `r length(byDots)` genes annotated with the GenBank accession, we will
try to map these genes to the HUGO gene symbols.

## Mapping GenBank Accession to HUGO Gene Symbols

### GenBank Accessions (ENA IDs)

We first obtain the GenBank accessions of the genes that are not already annotated with the HUGO gene symbols.

```{r, message = FALSE, tidy=TRUE, attr.output='style="max-height: 200px;"'}
# Get the GenBank accessions of the genes that are not already annotated with the HUGO gene symbols
gbAcc <- rownames(raw_counts_filtered)[byDots]

# Visualize the GenBank accessions, where we visualize the mean expression across biological replicates
gbExpr <- data.frame(rowMeans(raw_counts_filtered[byDots, grep("CTRL", colnames(raw_counts_filtered))]))
gbExpr <- cbind(gbExpr, rowMeans(raw_counts_filtered[byDots, grep("TGFb$", colnames(raw_counts_filtered))]))
gbExpr <- cbind(gbExpr, rowMeans(raw_counts_filtered[byDots, grep("VTP$", colnames(raw_counts_filtered))]))
gbExpr <- cbind(gbExpr, rowMeans(raw_counts_filtered[byDots, grep("TGFb_VTP", colnames(raw_counts_filtered))]))

# Rename the columns
colnames(gbExpr) <- c("CTRL", "TGFb", "VTP", "TGFb_VTP")

# Visualize the data as an interactive table, where gene accessions can be searched
DT::datatable(gbExpr, options = list(pageLength = 10))
```


### ID Mapping with Ensembl Biomart

#### Filter and Attribute Selection

The authors of the primary literature of this dataset indicated that the reference genome
used in this study is the [GRCh38/hg38](https://useast.ensembl.org/Homo_sapiens/Info/Index?db=core).
This is the same reference genome used in the current version of 
[Ensembl Biomart](https://www.ensembl.org/biomart/martview) (release 109). We will use
this resource to map the GenBank accessions to the HUGO gene symbols.

By investigation we found that GenBank, European Nucleotide Archive (ENA), and DDBJ are
part of the [International Nucleotide Sequence Database Collaboration (INSDC)](https://www.insdc.org/). 
The INSDC is a consortium of nucleotide sequence databases, where the three above mentioned
databases share information on the daily basis. The gene accession numbers used by GenBank
and ENA are identical, so we will search a matching filter that allows us to search for
the accession numbers in `biomart`.

```{r, message = FALSE, tidy=TRUE}
# Connect to the Ensembl Biomart with the hsapiens_gene_ensembl dataset
ensembl <- biomaRt::useDataset("hsapiens_gene_ensembl", 
                               mart = biomaRt::useMart("ensembl"))

# Find the filters that allows us to search for the accessions
# Filters should match "genbank", "ena", "euro", "ddbj", "insdc", or "embl"
biomartFilters <- biomaRt::listFilters(ensembl)
sel <- grep(biomartFilters$name, pattern = "(genbank)|(ena)|(euro)|(ddbj)|(insdc)|(embl)")

# Visualize the filters that match
knitr::kable(biomartFilters[sel, ]) %>% kableExtra::row_spec(12, background = "yellow") %>% 
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover", 
                "condensed", "responsive"), full_width = F, position = "center")
```

Among the filters, we found that `embl` has a description of European Nucleotide Archive ID(s).
Since the GenBank accessions are identical to the ENA accessions, we will use this filter
to search for the GenBank accessions.

Additionally, we need a set of returned attributes, primarily the **HGNC symbols**.

```{r, message = FALSE, tidy=TRUE}
# Find the attributes that allows us to retrieve the HGNC symbols
# We also search for the "embl" attribute, since to need to return it for ID mapping
knitr::kable(biomaRt::searchAttributes(mart = ensembl, "hgnc|^embl$") , format="html") %>%
 kableExtra::row_spec(c(1, 3), background = "yellow") %>% 
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover", 
                "condensed", "responsive"), full_width = F, position = "center")
```

It follows that the `hgnc_symbol` attribute corresponds to HGNC symbols.

Here, we tried to convert the GenBank accessions (ENA ID) to HGNC symbols.
Therefore, we will use the following information:
- Filter: `embl`
- Attributes: `hgnc_symbol`, `embl`
- Query values: `gbAcc`


#### Duplicated ENA IDs

Interestingly, Biomart does not accept the ENA IDs with the vwerion number, so we
removed the version number from the ENA IDs.

```{r, message = FALSE, tidy=TRUE}
# Remove the version number from the ENA IDs
gbAcc <- stringr::str_remove_all(gbAcc, "\\.[0-9]+")
```

Previously, we identified that all genes are unique using the ENA accession numbers
with the associated version number. However, it is likely that two previously 
considered unique genes are simply transcripts mapped to the same gene of 
different version. Therefore, we will check if there are any duplicated ENA IDs.

```{r, message = FALSE, tidy=TRUE}
# Check if there are any duplicated ENA IDs
sum(duplicated(gbAcc))

gbAccDuplicates <- unique(gbAcc[duplicated(gbAcc)])
```

We found that there are `sum(duplicated(gbAcc))` duplicated ENA ID. These 
duplications cover `r length(gbAccDuplicates)` unique ENA IDs. This
constitutes `r length(gbAccDuplicates)/nrow(raw_counts_filtered)*100`% of the total
filtered genes. This is only a small fraction of the total genes, so we will
proceed with the ID conversion and resolve the duplicates later.

#### ID Conversion
A query is constructed to retrieve the HGNC symbols for the ENA IDs, and
the result is saved to a file under the `Data` directory.

```{r, message = FALSE, tidy=TRUE}
# Remove duplicates
gbAcc <- unique(gbAcc)

# To reduce computation time from querying the Ensembl Biomart server, we will
# save the results to a file and load it if it exists
idConversionFile <- "./Data/gb_hgnc_conversion.rds"
if (file.exists(idConversionFile)) {
  # Load the ID conversion file directly
  idConversion <- readRDS(idConversionFile)
} else {
  # Query Biomart for the ID conversion
  idConversion <- biomaRt::getBM(filters = "embl", 
                                 attributes = c("hgnc_symbol", "embl"), 
                                 values = gbAcc, 
                                 mart = ensembl)
  
  # Save the results to a file
  saveRDS(idConversion, idConversionFile)
}
```

Among the genes in the filtered dataset, there are `r length(gbAcc)` genes that
are indicated with an ENA ID (GenBank ID). We check the number of genes that
are successfully converted to HGNC symbols.

```{r, message = FALSE, tidy=TRUE}
length(which(gbAcc %in% idConversion$embl))
```

Therefore, `r length(gbAcc) - length(which(gbAcc %in% idConversion$embl))` genes
are not successfully converted to HGNC symbols.

Interestingly, despite the inability to map some of the ENA IDs to HGNC symbols,
we obtained `r nrow(idConversion)` mappings. This result suggests that some of
the ENA IDs are mapped to multiple HGNC symbols.

```{r, message = FALSE, tidy=TRUE, attr.output='style="max-height: 200px;"'}
# Obtain the set of ENA IDs that are mapped to multiple HGNC symbols
multiMapped <- unique(idConversion$embl[duplicated(idConversion$embl)])

# Visualize the non-unique mappings
DT::datatable(idConversion[idConversion$embl %in% multiMapped, ])
```

To identify the source of the non-unique mappings, we directly searched for
the ENA IDs in the [Ensembl Biomart](https://www.ensembl.org/biomart/martview/)
and directly from the [ENA website](https://www.ebi.ac.uk/ena/browser/view/AC002456).
For example, the first ENA ID in the table above is `AC002456`. We found that in
Biomart, it is not only mapped to three different HGNC symbols, but also to
three unique Ensembl gene IDs. However, when we directly searched for `AC002456`
in the ENA website, we found that its description does not match to any of the 
given HGNC symbols. This suggests that Ensembl gene IDs are likely more accurate
and uniquely identify a gene than the ENA IDs. Since a single ENA ID can be mapped
to multiple HGNC symbols, corresponding to very different genes that variate in 
length, chromosomal locations, and sequence, we decided not to map any of the
non-uniquely mapped ENA IDs to HGNC symbols.

#### Translating ENA IDs to HGNC Symbols

```{r, message = FALSE, tidy=TRUE}
# Remove the non-unique mappings in the ID conversion table
idConversion <- idConversion[!(idConversion$embl %in% multiMapped), ]

# Number of uniquely mapped ENA IDs (including not mapped)
nrow(idConversion)
```


Since according to [ENA](https://www.ebi.ac.uk/ena/), the different version of the
same gene are considered as a single gene when processing accession numbers,
we will remove the version number from the `raw_counts_filtered` table.

```{r, message = FALSE, tidy=TRUE}
# Remove the version number from the ENA IDs in the filtered CPM table
raw_counts_filtered$Geneid <- gsub("\\.[0-9]+$", "", rownames(raw_counts_filtered))
```

Upon removal, we will then merge the ID conversion table with the `raw_counts_filtered`
table, where we specify that a record is matched if and only if the ENA ID is
identical.

```{r, message = FALSE, tidy=TRUE}
# Merged the HGNC symbols to the filtered raw counts table
raw_counts_filtered_translated <- merge(idConversion, raw_counts_filtered, 
                                        by.x = 2, by.y = "Geneid", all.y = TRUE)
```


```{r, message = FALSE, tidy=TRUE, echo=FALSE}
# If there is any empty entries in the merged table, fill them with NA
# This could be an empty string, rather than NA
sel <- which(raw_counts_filtered_translated$hgnc_symbol == "")
raw_counts_filtered_translated$hgnc_symbol[sel] <- NA
```

```{r, message = FALSE, tidy=TRUE, attr.output='style="max-height: 200px;"'}
# Since ENA IDs are only a subset of the genes in the filtered CPM table, we will
# fill in the missing values with the original names defined in the CPM table
sel <- is.na(raw_counts_filtered_translated$hgnc_symbol)
raw_counts_filtered_translated[sel, 2] <- raw_counts_filtered_translated[sel, 1]
        
# Rename the columns
colnames(raw_counts_filtered_translated)[1:2] <- c("unmapped_gid", "gname")

# Visualize
head(raw_counts_filtered_translated)
```

The first few genes only shows the ones that do not require mapping. Here we selectively
show some of the genes that require mapping.

```{r, message = FALSE, tidy=TRUE, attr.output='style="max-height: 200px;"'}
# Visualize the genes that require mapping
head(raw_counts_filtered_translated[raw_counts_filtered_translated$unmapped_gid 
                                      != raw_counts_filtered_translated$gname, ])
```

#### Duplicated Genes after Mapping

Recall that there are a small number of genes 
are considered duplicated due to the sharing of identical ENA accession number but
different versions. We will now check if any of these genes are mapped to the
same HGNC symbol. 

```{r, message = FALSE, tidy=TRUE}
# Any duplicated HGNC symbols?
summarizedCounts <- sort(table(raw_counts_filtered_translated$gname), decreasing = TRUE)

knitr::kable(summarizedCounts[summarizedCounts > 1][1:10]) %>% 
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", 
                "condensed", "responsive"), full_width = F, position = "center")
```

A small amount of duplications exist. By searching the genes against NCBI, we found
that these top duplicated genes, [CHCHD3](https://www.ncbi.nlm.nih.gov/gene/54927), 
[DGKI](https://www.ncbi.nlm.nih.gov/gene/9162), [PRKACB](https://www.ncbi.nlm.nih.gov/gene/5567),
and [RGS7](https://www.ncbi.nlm.nih.gov/gene/6000), etc. do not seen to be highly
related to the top expressed genes we previously identified. However, since
the RNAseq reads are mapped to multiple versions of the same gene, we will
concate the expression values of the duplicated genes. [@deschamps2020handling] 
[@li2010rna]

```{r, message = FALSE, tidy=TRUE}
# A data frame of deduplicated genes by summing the expression values
raw_counts_filtered_translated_no_dups <- aggregate(raw_counts_filtered_translated[ , 3:26], 
        by = list(raw_counts_filtered_translated$gname), FUN = sum)

# Rename the columns
colnames(raw_counts_filtered_translated_no_dups)[1] <- "gname"

# Check that there is no duplicated genes
summarizedCounts <- sort(table(raw_counts_filtered_translated_no_dups$gname), decreasing = TRUE)
sum(summarizedCounts > 1) == 0
```

At this point, we have obtained a set of unique, filtered CPM table with genes
identified by their HGNC symbols. Here is a summary of the expression statistics:

- **Number of genes:** `r nrow(raw_counts_filtered_translated_no_dups)`
- **Number of samples:** `r ncol(raw_counts_filtered_translated_no_dups) - 1`
- **Treatment conditions:** `r paste(unique(gsub("M[0-9]{2}\\.", "", colnames(raw_counts_filtered_translated_no_dups[, 2:25]))), collapse = ", ")`
- **Number of replicates per condition:** 6

Finally, we save a newly mapped version of the filtered CPM table.

```{r, message = FALSE, tidy=TRUE}
file <- "./Data/raw_counts_filtered_translated.csv"
write.csv(raw_counts_filtered_translated_no_dups, file, row.names = FALSE)
```


# Data Normalization

## Pre-normalization Statistics

In the [summary statistics](#summary-statistics) section, we have observed some 
variations in the expression values of the genes across the samples. Although
by the method description of the original publication, authors have tried to
reduce batch effects and other variations during the library preparation and
sequencing protocol, it is still likely that technical and biological
variations exist across the samples. [@garoffolo2022reduction]
This may be a result of the different amount of cells used for RNA extraction,
fragmentation process, or slight variations during PCR
amplication, etc. which may lead to variabilities in sequencing depth,
read length, and other factors that evetaully affect the quantification
of gene expression. Therefore, we first examined the distribution of the
expression values across the samples to identify any potential outliers.
Following this, data will be normalized to allow comparison of expression 
in genes we are interested in.

```{r, message = FALSE, tidy=TRUE}
# Rename the variable that is used to stored filtered, mapped, and deduplicated CPM table
expr <- raw_counts_filtered_translated_no_dups
rownames(expr) <- expr$gname
```


### Data Distribution - Boxplot

Boxplot allows us to visualize the distribution of expression values across
all genes and samples. Here we construct a boxplot based on the log2-transformed
`cpm` values. Only genes retained after the prior filtering and deduplication
steps are included in the boxplot.

```{r, message = FALSE, tidy=FALSE, fig.height = 5, fig.width = 10}
# Log2-transform the CPM values
expr_log2_cpm <- edgeR::cpm(expr[2:25], log = TRUE)

# Boxplot of the log2-transformed CPM values
# We will use the ggplot2 package to construct the boxplot

# Convert the data frame to a long format
expr2Boxplot <- data.frame(expr_log2_cpm)
expr2Boxplot$gname <- rownames(expr2Boxplot)
expr2Boxplot <- reshape2::melt(expr2Boxplot, id.vars = "gname")

# Specify treatment conditions for each sample
expr2Boxplot$Treatment <- gsub("M[0-9]{2}\\.", "", expr2Boxplot$variable)

# Median log2-CPM across samples
median <- median(apply(expr_log2_cpm, 2, median))

# Plot the boxplot
# A horizontal line is added to indicate the median log2-CPM across samples
pNoNorm <- ggplot(expr2Boxplot, aes(x = variable, y = value)) + 
    geom_boxplot() + 
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) + 
    labs(x = "Sample", y = "Log2-transformed CPM") +
    geom_hline(yintercept = median, color = "red", linetype = "dashed") +
    facet_wrap(~Treatment, nrow = 1, scales = "free_x")

pNoNorm
```
**Figure 2.** Expression of cSt-Cs under mechanical strain with pharmacological treatments

<br />

We observed









### Data Distribution - Density Plot

To further examine the distribution of expression values across the samples,
we plotted a density plot.

```{r, message = FALSE, tidy=FALSE, fig.height = 5, fig.width = 10}
# Density counting
densityCounts <- apply(expr_log2_cpm, 2, density)

# Calculate x, y limits across all samples
xlim <- 0
ylim <- 0
for (i in 1:length(densityCounts)) {
    xlim <- range(c(xlim, densityCounts[[i]]$x))
    ylim <- range(c(ylim, densityCounts[[i]]$y))
}

# Initialize line colours and type
cols <- rainbow(length(densityCounts))
ltys <- rep(1, length(densityCounts))

# Plot initialization
plot(densityCounts[[1]], xlim=xlim, ylim=ylim, type="n", 
ylab="Smoothing density of log2-CPM", main="")

# Adding each samples via a loop
for (i in 1:length(densityCounts)) {
    lines(densityCounts[[i]], col=cols[i], lty=ltys[i])
}

# Add legend
legend("topright", legend = colnames(expr_log2_cpm), 
       col = cols, lty = ltys, cex = 0.9,
       text.col = "black", bty = "n", merge = TRUE, bg = "grey90")
```
**Figure 3.** Density distribution of cSt-Cs gene expression across samples

<br />


## Normalization

### Normalization Methods
TMM

### Applying TMM Normalization

```{r, message = FALSE, tidy=TRUE}
# Convert raw counts data frame to a matrix
expr_matrix <- as.matrix(expr[2:25])
rownames(expr_matrix) <- expr$gname

# Create a DGEList object
expr_dge <- edgeR::DGEList(counts = expr_matrix, group = samples$treatment)

# Apply TMM normalization
expr_dge <- edgeR::calcNormFactors(expr_dge)

# Extract normalized CPM values for normalized counts
expr_norm_cpm <- edgeR::cpm(expr_dge)
```

## Post-normalization Comparative Statistics

### Boxplot

```{r, message = FALSE, tidy=FALSE, fig.height = 5, fig.width = 10}
# Log2-transform the CPM values
expr_norm_log2_cpm <- log2(expr_norm_cpm)

# Convert the data frame to a long format
normExpr2Boxplot <- data.frame(expr_norm_log2_cpm)
normExpr2Boxplot$gname <- rownames(normExpr2Boxplot)
normExpr2Boxplot <- reshape2::melt(normExpr2Boxplot, id.vars = "gname")

# Setting group variable for normalized and unnormalized data
normExpr2Boxplot$normalized <- "Normalized"
expr2Boxplot <- expr2Boxplot[ , -4]
expr2Boxplot$normalized <- "Original Counts"

# Combine normalized and unnormalized data for plotting
compExpr2Boxplot <- rbind(expr2Boxplot, normExpr2Boxplot)

# Median log2-CPM across samples of the normalized data
medianNormalzied <- median(apply(expr_norm_log2_cpm, 2, median))

# Plot the boxplot
# A horizontal line is added to indicate the median log2-CPM across samples
ggplot(compExpr2Boxplot, aes(x = variable, y = value)) + 
    geom_boxplot() + 
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) + 
    labs(x = "Sample", y = "Log2-transformed CPM") +
    geom_hline(yintercept = median, color = "red", linetype = "dashed", 
        show.legend = "Median of original counts") +
    geom_hline(yintercept = medianNormalzied, color = "blue", linetype = "dashed", 
        show.legend = "Median of normalized counts") +
    facet_wrap(~normalized, nrow = 1, scales = "free_x")
```





# Interpretation and Analysis
- What are the control and test conditions of the dataset?


- Why is the dataset of interest to you?


- Were there expression values that were not unique for specific genes? How did you handle these?


- Were there expression values that could not be mapped to current HUGO symbols?


- How many outliers were removed?


- How did you handle replicates?


- What is the final coverage of your dataset?












# Journal Link
The link to the concurrent journal entry can be found [here](https://github.com/bcb420-2023/Jielin_Yang/wiki/Dataset-Cleaning-and-Identifier-Mapping).

# References